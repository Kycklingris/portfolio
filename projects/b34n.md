---
layout: project
title: B34-N
permalink: /b34n.html
---
# Self-reflection: 

There have mainly been two things that I should improve upon.  

 1. is that, as the main networking developer I didn’t really share with the rest of the team what I already knew and had learned in the beginning of the project, which meant that it wasn’t unusual for the other team members to have been working on a feature for multiple hours or even days only to have it fixed either with a couple of lines of code by me, or with a simple explanation when I found out about the problem. These problems would have been mitigated by just taking a couple of hours to explain the main points of the networking. 

 2. Would be that I did not really comment my code that much, in this case it did not cause any major problems as my code was mostly only ever touched by me and when someone was going to work with it, I usually explained the main points. But it is a fact that most of my code remained uncommented, mostly due to a feeling of lack of time. This would have been especially important when it comes to server only methods and such, which there were a couple of, that were only commented on in the file rather than using summary tags or whatever it is called in c#. 

There was also a problem when it came to the entire team (and as a member of the entire team me as well), that also ties into point number one. Which is that there was a lack of communication meaning it was quite often that two people were implementing the same featuring in parallel without the other knowing, partially due to us having unspecific Jira tasks but mainly due to us not announcing what we were working on. 

Last minute add on, as the main networking developer, I should have spent more time making sure that there was a straightforward way to test features, without having to start two clients. Without one, it made it so that if networking wasn’t working, we couldn’t really send a build to QA, nor send one to the designers so they could change values. 

# My contributions: 

The main points of my work have been networking, throwables support items and hacking (of course, a lot of bug fixing and smaller things as well). Now, we did not get much done since none of us programmers knew what type of game we were supposed to make until the end of the third week, so there is not all that much to show. 

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using Mirror;
using UnityEngine.UI;

public class Thrower : NetworkBehaviour
{
    [SerializeField] private Throwable healingThrowable;
    // if less than 0, then no throwable is selected
    [SerializeField] private int selected = 0;
    [SerializeField] private float range = 10.0f;
    [SerializeField] private float cooldown = 20.0f;
    [SerializeField] private float energyDrain = 30.0f;

    [SerializeField] private LineRenderer lineRenderer;
    public FMODUnity.EventReference throwSoundEffect;
    [SerializeField] private Animator animator;

    private const int linePoints = 25;

    private bool aiming = false;

    private Vector3 target;

    private List<Vector3> path;

    private Vector2 mousePosition = new Vector2(0.0f, 0.0f);
    private float lastThrown;

    private float time;
    private float scaledValue;
    private Image healingIcon;
    private bool startTimer;
    private EnergyManagement energyManagement;
    private Color32 fadedColor;
    private Color32 normalColor;

    private void Awake()
    {
        lastThrown = -cooldown;
        energyManagement = GetComponent<EnergyManagement>();
        RemoveLine();
    }

    public override void OnStartLocalPlayer()
    {
        healingIcon = GameObject.Find("HealingIcon").GetComponent<Image>();
        startTimer = false;
        time = 0;
        fadedColor = new Color32(255, 255, 255, 100);
        normalColor = new Color32(255, 255, 255, 255);

    }

    private void Start()
    {
    }

    private void Update()
    {
        if (startTimer)
        {
            //Debug.Log(time);
            time += Time.deltaTime;
            scaledValue = time / cooldown;
            healingIcon.fillAmount = scaledValue;

            if (time >= cooldown)
            {
                startTimer = false;
                healingIcon.fillAmount = 1;
                time = 0;
            }
        }

        if (isLocalPlayer)
        {
            if (energyManagement.CurrentEnergy < energyDrain)
            {
                healingIcon.color = fadedColor;
            }
            else
            {
                healingIcon.color = normalColor;
            }

        }
        if (!aiming) return;

        var nullableTarget = CalcTarget();
        if (nullableTarget == null)
        {
            RemoveLine();
            return;
        }
        else
        {
            target = nullableTarget.Value;
        }

        var position = transform.position;

        DrawLine(position, target);


    }

    public void OnMouse(InputAction.CallbackContext mouseContext)
    {
        if (selected < 0 && !aiming) return;

        if (mouseContext.started)
        {
            if (lastThrown + cooldown >= Time.time) return;
            aiming = true;
        }
        else if (mouseContext.canceled)
        {
            aiming = false;
            if (energyManagement.CurrentEnergy >= energyDrain)
            {
                Throw();
                startTimer = true;

            }
            RemoveLine();
        }
    }

    public void OnLook(InputAction.CallbackContext lookContext)
    {
        mousePosition = lookContext.ReadValue<Vector2>();
    }

    private void Throw()
    {
        if (path == null) return;

        CMDThrow(target);
        RemoveLine();
    }

    [Command] // Spawns it on server and then forces that onto the clients.
    void CMDThrow(Vector3 target)
    {
        if (lastThrown + cooldown >= Time.time) return;
        lastThrown = Time.time;

        energyManagement.ConsumeEnergy(energyDrain);
        RPCThrow();
        

        var distance = Vector3.Distance(target, transform.position);

        var tSize = 1.0f / (float)linePoints;

        var path = new List<Vector3>();

        for (int i = 0; i < linePoints; i++)
        {
            float t = tSize * (float)(i + 1);
            var point = SampleParabola(transform.position, target, distance / 3, t);
            path.Add(point);
        }

        
        var obj = Instantiate(healingThrowable, path[0], Quaternion.identity);
        obj.path = path;

        NetworkServer.Spawn(obj.gameObject);
    }

    [ClientRpc]
    private void RPCThrow()
    {
        
        animator.SetTrigger("Throw");
        FMODUnity.RuntimeManager.PlayOneShot(throwSoundEffect, transform.position);
    }


    private void DrawLine(Vector3 start, Vector3 end)
    {
        lineRenderer.enabled = true;
        lineRenderer.positionCount = linePoints;

        var distance = Vector3.Distance(start, end);

        var tSize = 1.0f / (float)linePoints;

        path = new List<Vector3>();

        for (int i = 0; i < linePoints; i++)
        {
            float t = tSize * (float)(i + 1);
            var point = SampleParabola(start, end, distance / 3, t);
            lineRenderer.SetPosition(i, point);
            path.Add(point);
        }
    }

    private void RemoveLine()
    {
        lineRenderer.enabled = false;
        path = null;
       
    }

    private Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t)
    { // https://forum.unity.com/threads/generating-dynamic-parabola.211681/#post-1426169
        float parabolicT = t * 2 - 1;
        if (Mathf.Abs(start.y - end.y) < 0.1f)
        { // Start and end are roughly level, pretend they are - simpler solution with less steps
            var travelDirection = end - start;
            var result = start + t * travelDirection;
            result.y += (-parabolicT * parabolicT + 1) * height;
            return result;
        }
        else
        { //start and end are not level, gets more complicated
            var travelDirection = end - start;
            var levelDirection = end - new Vector3(start.x, end.y, start.z);
            var right = Vector3.Cross(travelDirection, levelDirection);
            var up = Vector3.Cross(right, travelDirection);
            if (end.y > start.y) up = -up;
            var result = start + t * travelDirection;
            result += ((-parabolicT * parabolicT + 1) * height) * up.normalized;
            return result;
        }
    }

    private Vector3? CalcTarget()
    {
        Ray ray = Camera.main.ScreenPointToRay(mousePosition);

        RaycastHit hit;
        Vector3 target;
        if (Physics.Raycast(ray, out hit, Mathf.Infinity, LayerMask.GetMask("Ground")))
        {
            target = hit.point;
        }
        else return null;

        var currentPosition = transform.position;
        var distance = Mathf.Abs(Vector3.Distance(currentPosition, target));

        if (distance <= range)
        {
            if (distance < 2f) return null;

            return target;
        }

        var direction = (target - currentPosition).normalized;
        var newTarget = currentPosition + (direction * range);

        newTarget.y += 2.0f;

        RaycastHit hitUp;
        bool up = Physics.Raycast(newTarget, Vector3.up, out hitUp, Mathf.Infinity);

        RaycastHit hitDn;
        bool dn = Physics.Raycast(newTarget, Vector3.down, out hitDn, Mathf.Infinity);

        if (up && dn)
        {
            if (Vector3.Distance(newTarget, hitUp.point) < Vector3.Distance(newTarget, hitDn.point)) return hitUp.point;
            else return hitDn.point;
        }
        else if (up) return hitUp.point;
        else if (dn) return hitDn.point;
        else return null;
    }
}

```

Thrower.cs I wouldn’t call it especially impressive considering that the main part (the parabola math) was copied from a Stack overflow post. I did however meet some strange behavior where manually multiplying a direction vector with a value and drawing a ray from the position in said direction infinitely resulted in two different lines on screen, which is why there are some strange things around line 260. 

```c#
using System.Collections;
using UnityEngine;
using UnityEngine.InputSystem;
using Mirror;
using UnityEngine.UI;

public class Hacking : NetworkBehaviour
{
    [SerializeField] private GameObject hackingField;
    [SerializeField] private HealthScript healthScript;
    // [SerializeField] private Stats stats;
    [SerializeField] private float energyDrain;
    [SerializeField] private float activeTime;
    [SerializeField] private float activeMoveSpeed;
    [SerializeField] private PlayerInputController playerInputController;
    [SerializeField] private Animator animator;
    public FMODUnity.EventReference hackingSoundEffect;
    public EnergyManagement energyManager;

    private Color32 fadedColor;
    private Color32 normalColor;

    private bool hacking = false;
    private float originalMoveSpeed;

    private float time;
    private float scaledValue;
    private Image hackingIcon;
    private bool startTimer;


    public override void OnStartLocalPlayer()
    {
        base.OnStartLocalPlayer();

        originalMoveSpeed = playerInputController.moveSpeed;
        hackingIcon = GameObject.Find("HackingIcon").GetComponent<Image>();
        fadedColor = new Color32(255, 255, 255, 100);
        normalColor = new Color32(255, 255, 255, 255);

    }

    private void Start()
    {
        startTimer = false;

        
    }

    private void Update()
    {
        if (startTimer)
        {
            time += Time.deltaTime;
            scaledValue = time / activeTime;
            hackingIcon.fillAmount = scaledValue;

            if (time >= activeTime)
            {
                startTimer = false;
                hackingIcon.fillAmount = 1;
                time = 0;
            }
        }


        if (isLocalPlayer)
        {
            if (energyManager.CurrentEnergy < energyDrain)
            {
                hackingIcon.color = fadedColor;
            }
            else
            {
                hackingIcon.color = normalColor;
            }

        }
    }

    public void OnHackClick(InputAction.CallbackContext context)
    {
        if (!context.performed) return;
        if (hacking) return;

        if (context.ReadValue<float>() > 0.5f && energyManager.CurrentEnergy >= energyDrain)
        { // Pressed
            // Hacking started
            startTimer = true;
            CMDStartHacking();
        }
    }

    private void DrainEnergy()
    {
        // Drain Energy
        energyManager.ConsumeEnergy(energyDrain);
        // healthScript.
    }

    [Command]
    private void CMDStartHacking()
    {
        RPCStartHacking();
        DrainEnergy();
        StartCoroutine(ActiveTime());
    }

    [ClientRpc]
    private void RPCStartHacking()
    {
        hacking = true;
        hackingField.SetActive(true);

        animator.SetTrigger("Hacking");
        FMODUnity.RuntimeManager.PlayOneShot(hackingSoundEffect, transform.position);

        if (isLocalPlayer)
        {
            playerInputController.moveSpeed = activeMoveSpeed;
        }
    }

    [ClientRpc]
    private void RPCStopHacking()
    {
        hacking = false;

        hackingField.SetActive(false);

        if (isLocalPlayer)
        {
            playerInputController.moveSpeed = originalMoveSpeed;
        }
    }

    IEnumerator ActiveTime()
    {
        yield return new WaitForSeconds(activeTime);

        // Hacking disabled
        RPCStopHacking();
        hacking = false;
        hackingField.SetActive(false);

    }

    public void TargetEntered(IHackable target)
    {
        if (!hacking || !isServer) return;

        target.StartedHack();
    }
}


```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IHackable 
{
    public void StartedHack();
}
```

Hacking.cs Just here since I wrote it, not really anything interesting. It just enables a trigger sphere, and checks if a game object implementing IHackable.cs has entered, if so, “hacks” it. 

```c#
 var right = Camera.main.transform.right;
var forward = Vector3.Cross(right, Vector3.up);

// Calculate the movement vector
var movementRight = right * _move.x;
var movementForward = forward * _move.y;

var movement = movementRight + movementForward;

// Convert the movement to a direction vector relative to the character look direction
var localMovement = transform.InverseTransformDirection(movement).normalized;

if (_animator != null)
{
	_animator.SetFloat("X", localMovement.x, 0.15f, Time.fixedDeltaTime);
	_animator.SetFloat("Z", localMovement.z, 0.15f, Time.fixedDeltaTime);
}

// transform.Translate(movement * currentSpeed * Time.fixedDeltaTime, Space.World);
_characterRB.velocity = movement * currentSpeed;

if (movement != Vector3.zero)
{
	currentSpeed = Mathf.Lerp(currentSpeed, moveSpeed, acceleration * Time.fixedDeltaTime);
}
else
{
	currentSpeed = Mathf.Lerp(currentSpeed, 0, deceleration * Time.fixedDeltaTime);
}

// This method is called whenever a "look" action is performed
public void OnLook(InputAction.CallbackContext lookContext)
{
	// Get the mouse position in screen coordinates
	Vector2 mousePosition = lookContext.ReadValue<Vector2>(); ;

	// Convert the mouse position to a ray that projects into the scene
	Ray mouseRay = Camera.main.ScreenPointToRay(mousePosition);

	// Define a plane that intersects with the scene at the object's position
	Plane groundPlane = new Plane(Vector3.up, transform.position);
	float rayDistance;

	// Check if the mouse ray intersects with the ground plane
	if (groundPlane.Raycast(mouseRay, out rayDistance))
	{
		// Get the point at which the mouse ray intersects with the ground plane
		Vector3 lookPoint = mouseRay.GetPoint(rayDistance);

		// Make the object look at the look point
		transform.LookAt(lookPoint);
	}
}

```

Vector math Some quite janky vector mathematics (around line 151, but should be linked to it), that makes sure the character moves based on the camera while also keeping the character looking towards the mouse direction. 

With networking there isn’t really a specific script to point towards as it’s spread out over almost all of them, but main points would be that there is UPNP port forwarding and network discovery (only the UI is custom, the networking for it comes with mirror). 

# Minor list: 

 - Added FMOD and sound events for everything. 

```c#
//Look At TargetPosition
if (minDistance <= range)
{
	var baseForward = (currentTarget.position - transform.position).normalized;

	basePlatform.forward = new Vector3(baseForward.x, 0.0f, baseForward.z);
	barrel.LookAt(currentTarget);
	TryShoot();
	targetInBounds = true;
}
else
{
	targetInBounds = false;
}
```

 - Made the turrets aim towards the player only rotating around z for the base and “up and down” for the barrel (is wrong in the build as it was changed to being a mortar last minute). Turret.cs 

```c#
using Mirror.Discovery;

using Mono.Nat;

public class MultiplayerMenuScript : MonoBehaviour
{
    [SerializeField] private TMPro.TMP_InputField hostInputField;
    private CustomNetworkRoomManager networkManager;
    private NetworkDiscovery networkDiscovery;

    public void Quit()
    {
        Application.Quit();
    }

    private void Awake()
    {
        networkManager = GameObject.FindWithTag("NetworkManager").GetComponent<CustomNetworkRoomManager>();
        networkDiscovery = GameObject.FindWithTag("NetworkManager").GetComponent<NetworkDiscovery>();
    }

    private void Start()
    {
        networkManager.StopHost();
        networkManager.StopServer();
        networkManager.StopClient();
    }

    public void OnHost()
    {		
        StartCoroutine("UpnpPortMapping", 10.0f);
        networkManager.maxConnections = 2;
        networkManager.StartHost();
        networkDiscovery.AdvertiseServer();
    }

    public void OnJoin()
    {
        const string scheme = "kcp";
        const int port = 7777;

        var host = hostInputField.text;
        var uriBuilder = new System.UriBuilder();

        uriBuilder.Host = host;
        uriBuilder.Port = port;
        uriBuilder.Scheme = scheme;

        networkManager.StartClient(uriBuilder.Uri);
    }

    IEnumerator UpnpPortMapping(float maxTime)
    {
        NatUtility.DeviceFound += DeviceFound;
        NatUtility.StartDiscovery();

        Debug.Log($"Upnp Searching: {NatUtility.IsSearching}");

        while (maxTime > 0.0f)
        {
            if (!NatUtility.IsSearching) 
            {
                yield break;
            }
            
            maxTime -= 0.5f;
            yield return new WaitForSeconds(.5f);
        }

        NatUtility.StopDiscovery();
        Debug.Log("Upnp Port forwarding has failes.");
        yield break;
    }

    async void DeviceFound(object sender, DeviceEventArgs args)
    {
        NatUtility.StopDiscovery();
        INatDevice device = args.Device;
        await device.CreatePortMapAsync(new Mapping(Protocol.Udp, 7777, 7777));
        Debug.Log("Upnp has successfully port forwarded.");
    }
}
```

 - Main menu (also has the UPNP port forwarding) MultiplayerMenuScript.cs. 

 - Animation blend tree for single shot and continuous shooting, separate leg and body animations, throw animation, dash and hacking. As well as animation events in code. 

 - Added most of the art assets, and some of the VFX. 

```c#
using UnityEngine;
using Mirror;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class LobbyPlayerScript : NetworkRoomPlayer
{
	private Button attackButton;
	private Button supportButton;

	[SyncVar(hook = nameof(SelectionChanged))]
	public SelectedCharacter selection = SelectedCharacter.none;

	private LobbyManager lobbyManager;

	private void Awake()
	{
		lobbyManager = GameObject.FindWithTag("LobbyManager").GetComponent<LobbyManager>();

		attackButton = GameObject.Find("AttackSelectButton").GetComponent<Button>();
		supportButton = GameObject.Find("SupportSelectButton").GetComponent<Button>();
	}

	private new void Start()
	{
        DontDestroyOnLoad(this.gameObject);
        if (isLocalPlayer)
		{
			attackButton.onClick.AddListener(OnAttackButtonClick);
			supportButton.onClick.AddListener(OnSupportButtonClick);
			
		}
		else
		{
			lobbyManager.otherPlayerJoined = true;
		}
	}

	public override void OnClientExitRoom()
	{
		if (!isLocalPlayer)
		{
			SelectionChanged(selection, SelectedCharacter.none);
			lobbyManager.otherPlayerJoined = false;
		}
	}

	private void SelectionChanged(SelectedCharacter _Old, SelectedCharacter _New)
	{
		if (SceneManager.GetActiveScene().name != "Lobby") return;

		if (_New == SelectedCharacter.Attack)
		{
			attackButton.interactable = false;
			return;
		}

		if (_New == SelectedCharacter.Support)
		{
			supportButton.interactable = false;
			return;
		}

		if (_Old == SelectedCharacter.Attack)
		{
			attackButton.interactable = true;
		}
		else if (_Old == SelectedCharacter.Support)
		{
			supportButton.interactable = true;
		}
	}

	private void OnAttackButtonClick() // Attack select
	{
		CMDSetPlayerSelection(SelectedCharacter.Attack);
		GetComponent<NetworkRoomPlayer>().CmdChangeReadyState(true);
	}

	private void OnSupportButtonClick() // Support select
	{
		CMDSetPlayerSelection(SelectedCharacter.Support);
		GetComponent<NetworkRoomPlayer>().CmdChangeReadyState(true);
	}

	[Command]
	private void CMDSetPlayerSelection(SelectedCharacter selected)
	{
		if (selection == SelectedCharacter.none)
		{
			selection = selected;
		}
	}
}
```

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Mirror;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class LobbyManager : NetworkBehaviour
{
    [SerializeField]
    private Button attackButton;

    [SerializeField]
    private Button supportButton;

    [SerializeField]
    private GameObject secondPlayerIndicator;

    private bool _otherPlayerJoined = false;
    public bool otherPlayerJoined
    {
        get { return _otherPlayerJoined; }
        set
        {
            SetOtherPlayerIndicator(value);
            _otherPlayerJoined = value;
        }
    }

    private CustomNetworkRoomManager networkManager;

    // Makes sure that if a character has already been selected then that button will be grayed out.
    // As well as second player indicator
    private void Start()
    {
        const string lobbyPlayersTag = "LobbyPlayer";
        var players = GameObject.FindGameObjectsWithTag(lobbyPlayersTag);

        networkManager = GameObject.FindWithTag("NetworkManager").GetComponent<CustomNetworkRoomManager>();
        var playerCount = networkManager.numPlayers;

        if (playerCount == 2)
        {
            otherPlayerJoined = true;
        }
        else
        {
            otherPlayerJoined = false;
        }

        foreach (GameObject player in players)
        {
            var selection = player.GetComponent<LobbyPlayerScript>().selection;

            if (selection == SelectedCharacter.Attack)
            {
                attackButton.interactable = false;
            }
            else if (selection == SelectedCharacter.Attack)
            {
                supportButton.interactable = false;
            }
        }
    }

    private void SetOtherPlayerIndicator(bool joined)
    {
        if (SceneManager.GetActiveScene().name != "Lobby") return;
        if (joined)
        {
            secondPlayerIndicator.SetActive(false);
        }
        else
        {
            secondPlayerIndicator.SetActive(true);
        }

    }

    public void OnExitButtonClick()
    {
        GameObject.FindWithTag("NetworkManager").GetComponent<CustomNetworkRoomManager>().StopHost();
    }
}
```

 - Most of the lobby LobbyPlayerScript.cs LobbyManager.cs. 

 - The rest is too minor for me to remember, and as Jira was taken down, I can’t just look up what has been done. 